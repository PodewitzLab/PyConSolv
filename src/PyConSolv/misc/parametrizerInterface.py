import os
import shutil
import subprocess

import numpy as np

from .ions import ionlib
from ..utils.charge import ChargeChanger
from ..utils.colorgen import Color
from ..interfaces.amber import amberInterface
from ..interfaces.calculate import Calculation
from ..misc.inputparser import XYZ
from ..interfaces.multiWFN import MultiWfnInterface


class Parametrizer:
    def __init__(self, structurePath : str, stype:str):
        """
        Class used to parametrize arbitrary structures using ORCA/Amber/Multiwfn and RESP charges

        Parameters:
            :param string structurePath: path to XYZ file containing the solvent geometry
            :param string stype: calculation type SLV for solvent or CTI for counterion

        Class variables:
            - self.charges = contains the RESP charges generated by Multiwfn
            - self.db_file = location of file which stores the atom radius
            - self.db_metal_file = location of the file which stores the radius for metals
            - self.inputpath = location of item to be parametrized
            - self.input = directory of input file
            - self.outpath = PDB file for item to be parametrized
            - self.solventmol2 = Mol2 file for item to be parametrized
            - self.orca_inp = input file for orca
            - self.watermodel = water models available in amber
        """
        self.db_file = os.path.split(__file__)[0] + '/../db/atom-radius.txt'
        self.db_metal_file = os.path.split(__file__)[0] + '/../db/metal-radius.txt'

        self.stype = stype
        self.inputpath = '/'.join(structurePath.split('/')[:-1]) +'/{}_param/'.format(self.stype)
        self.input = self.inputpath + structurePath.split('/')[-1]

        try:
            os.mkdir(self.inputpath)
        except:
            print('The folder contains a previously performed {} parametrization...\n'.format(self.stype))
        shutil.copyfile(structurePath, self.input)
        self.outpath = self.inputpath
        self.solventPDB = None
        self.solventmol2 = None
        self.waterModel = {}

        self.orca_inp = '''{}
! OPT
{}

%PAL NPROCS {} END

%scf
maxiter 350
end

* xyzfile {} 1 input.xyz
'''


    def parseXYZ(self):
        """
        Prepare the input XYZ file for paremetrization

        Parameters:

        Class variables:
        """

        self.xyz = XYZ(self.db_file, self.db_metal_file)
        self.xyz.readXYZ(self.input)
        if len(self.xyz.atoms) == 1:
            print("Single atom is used as counterion...")
        else:
            self.xyz.calculateDistanceMatrix()
            self.xyz.generateAdjacencyMatrix()
            self.xyz.generateLinkList()
            self.xyz.connectedCompponents()
            self.xyz.assignChain()
            self.xyz.createPDB()
            self.xyz.writePDBFiles(self.outpath)
            self.solventPDB = self.xyz.filenames[0]
            self.solventmol2 = np.array(self.xyz.ligands)[0]

    def singleAtom(self, charge: int = 1, amount = 1):
        linetoadd = ''
        templateFRCMOD='''Remark line goes here
MASS
CT  {}   Mass added

BOND

ANGLE

DIHE

IMPROPER

NONBON
  CT           {}  {}             Nonbonded parameters 
        '''

        templateMOL2 = '''@<TRIPOS>MOLECULE
CTI
    7     6     1     0     0
SMALL
RESP Charge


@<TRIPOS>ATOM
      1 {}           0.0000     0.0000     0.0000 {}         1 CTI       {}
@<TRIPOS>BOND
@<TRIPOS>SUBSTRUCTURE
     1 CTI         1 TEMP              0 ****  ****    0 ROOT
'''
        ionsAvailable = ionlib()
        if self.xyz.atoms[0] in ionsAvailable.ionsinAmber.keys():
            if charge == ionsAvailable.ionsinAmber.get(self.xyz.atoms[0])[1]:
                linetoadd = 'addions LIG {} {}\n'.format(ionsAvailable.ionsinAmber.get(self.xyz.atoms[0])[0], amount)
        return linetoadd

    def runAntechamber(self, charge: int):
        """
        Read RESP charges generated by Multiwfn and saved in orca_opt.molden.chg

        Parameters:

        Class variables:
            - self.charges = contains the RESP charges generated by Multiwfn
        """

        self.amber = amberInterface(self.outpath)
        self.amber.antechamber(self.solventPDB.split('.')[0], charge = charge)
        self.amber.runParmchk2(self.solventmol2)


    def getMultiwfnCharges(self):
        """
        Read RESP charges generated by Multiwfn and saved in orca_opt.molden.chg

        Parameters:

        Class variables:
            - self.charges = contains the RESP charges generated by Multiwfn
        """
        f = open(self.outpath + '{}opt/orca_opt.molden.chg'.format(self.stype), 'r')
        self.charges = []
        iterator = 0
        for line in f:
            iterator += 1
            self.charges.append([line.split()[-1]]) # this maintains compatibility with the multiple fragment approach
        f.close()


    def changeCharges(self):
        fin = self.inputpath + '/A.mol2'  # read mol2 files corresponding to the structure pdb
        fout = self.outpath + '/{}.mol2'.format(self.stype)
        self.chargeChanger = ChargeChanger()
        self.chargeChanger.change(fin, fout, '{}'.format(self.stype), self.charges)
    def changeCharges_old(self):
        """
                Create final mol2 files for tleap, using the charges from the RESP calculation

                Parameters:
                    :param string path: folder where files are located/created
                Class variables:

                """
        iterator = 0  # keeps track of current atom id
        switch = 0

        fin = open(self.inputpath + '/A.mol2', 'r')  # read mol2 files corresponding to the solvent pdb
        fout = open(self.outpath + '/{}.mol2'.format(self.stype), 'w')  # create new mol2 file
        for line in fin:
            if 'USER_CHARGES' in line:
                fout.write('RESP Charge\n')
            elif '@<TRIPOS>ATOM' in line:
                switch = 1
                fout.write(line)
            elif '@<TRIPOS>BOND' in line:
                fout.write(line)
                switch = 2
            elif '@<TRIPOS>SUBSTRUCTURE' in line:
                fout.write(line)
                switch = 3
            elif '@<TRIPOS>MOLECULE' in line:
                fout.write(line)
                switch = 4
            else:
                if switch == 1:

                    tmp_line = line.split()[:-1]  # remove old charge

                    tmp_line.append(float(self.charges[iterator]))  # add resp charge
                    tmp_line[-2] = '{}'.format(self.stype)
                    fout.write(
                        '{:>7} {:<7}    {:>7}    {:>7}    {:>7}   {:<2}    {}  {:>2} {:>9.6f}\n'.format(*tmp_line))
                    iterator += 1
                elif switch == 3:
                    fout.write('     1 {}         1 TEMP              0 ****  ****    0 ROOT\n'.format(self.stype))
                    switch = 0
                elif switch == 4:
                    fout.write('{}\n'.format(self.stype))
                    switch = 0
                else:
                    if 'bcc' in line:
                        fout.write(line.replace('bcc', 'RESP Charge'))
                    else:
                        fout.write(line.replace('ar', '1'))
        fout.close()
        fin.close()

    def runORCA(self, method: str = 'PBE0', basis: str = 'def2-SVP', DSP: str = 'D4', CPU: int = 12, cpcm = '', charge: str = 0):
        try:
            os.mkdir(self.outpath + '/{}opt/'.format(self.stype))
        except:
            print('Previous calculations found, checking...\n')
        os.chdir(self.outpath + '/{}opt/'.format(self.stype))
        shutil.copyfile(self.input, self.outpath + '/{}opt/input.xyz'.format(self.stype))
        self.calc = Calculation(self.outpath)
        self.calc.checkpath()

        self.method = '! {} {} {}'.format(method,basis,DSP)
        f = open(self.outpath + '/{}opt/orca_opt.inp'.format(self.stype), 'w')
        if 'EPSILON' not in cpcm:
            if cpcm != '':
                cpcm = '!CPCM({})'.format(cpcm)
        f.write(self.orca_inp.format(self.method, cpcm, CPU, charge))
        f.close()

        self.calc.calculate(calctype='opt', calcpath = '/{}opt'.format(self.stype))
        command = 'orca_2mkl orca_opt -molden'
        calc = subprocess.run([command], shell=True)

        os.chdir(self.outpath)

    def runMultiwfn(self):
        os.chdir(self.outpath + '/{}opt/'.format(self.stype))
        self.multiwfn = MultiWfnInterface(self.outpath+'/{}opt/'.format(self.stype), orcaname = 'orca_opt')
        self.multiwfn.run()

        os.chdir(self.outpath)
    def run(self, method: str = 'PBE0', basis: str = 'def2-SVP', DSP: str = 'D4', CPU: int = 12,
            cpcm = '', charge: int = 0):
        if os.path.exists(self.inputpath + '../done'):
            print('Previously performed parametrization is complete, using solvent\n')
            return
        self.parseXYZ()
        if len(self.xyz.atoms) == 1:
            print("Single atom is used as counterion...")
            self.singleAtom(charge = charge)
        else:
            self.runORCA(method, basis, DSP, CPU, cpcm, charge)
            self.runMultiwfn()
            self.runAntechamber(charge)
            self.getMultiwfnCharges()
            self.changeCharges()
            dest = shutil.copyfile(self.inputpath + '/A.frcmod', self.inputpath + '/{}.frcmod'.format(self.stype))
        print(Color.GREEN + 'Solvent parametrization complete!\n' + Color.END)
        f = open(self.inputpath + '../done', 'w')
        f.close()
